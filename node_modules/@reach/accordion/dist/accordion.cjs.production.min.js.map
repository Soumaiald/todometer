{"version":3,"file":"accordion.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["/**\n * Welcome to @reach/accordion!\n *\n * TODO: Animation examples\n *\n * @see Docs     https://reacttraining.com/reach-ui/accordion\n * @see Source   https://github.com/reach/reach-ui/tree/master/packages/accordion\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#accordion\n */\n\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  checkStyles,\n  createNamedContext,\n  forwardRefWithAs,\n  isBoolean,\n  isNumber,\n  makeId,\n  noop,\n  useForkedRef,\n  wrapEvent,\n} from \"@reach/utils\";\nimport {\n  createDescendantContext,\n  DescendantProvider,\n  useDescendant,\n  useDescendantKeyDown,\n  useDescendants,\n} from \"@reach/descendants\";\nimport { useId } from \"@reach/auto-id\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\n\nconst AccordionDescendantContext = createDescendantContext<\n  HTMLElement,\n  DescendantProps\n>(\"AccordionDescendantContext\");\nconst AccordionContext = createNamedContext<IAccordionContext>(\n  \"AccordionContext\",\n  {} as IAccordionContext\n);\nconst AccordionItemContext = createNamedContext<IAccordionItemContext>(\n  \"AccordionItemContext\",\n  {} as IAccordionItemContext\n);\nconst useAccordionContext = () => useContext(AccordionContext);\nconst useAccordionItemContext = () => useContext(AccordionItemContext);\n\n////////////////////////////////////////////////////////////////////////////////\n\nexport enum AccordionStates {\n  Open = \"open\",\n  Collapsed = \"collapsed\",\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Accordion\n *\n * The wrapper component for all other accordion components. Each accordion\n * component will consist of accordion items whose buttons are keyboard\n * navigable using arrow keys.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-1\n */\nexport const Accordion = forwardRef<HTMLDivElement, AccordionProps>(\n  function Accordion(\n    {\n      children,\n      defaultIndex,\n      index: controlledIndex,\n      onChange,\n      readOnly = false,\n      collapsible = false,\n      multiple = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    /*\n     * You shouldn't switch between controlled/uncontrolled. We'll check for a\n     * controlled component and track any changes in a ref to show a warning.\n     */\n    const wasControlled = typeof controlledIndex !== \"undefined\";\n    const { current: isControlled } = useRef(wasControlled);\n\n    const [descendants, setDescendants] = useDescendants<\n      HTMLElement,\n      DescendantProps\n    >();\n\n    const id = useId(props.id);\n\n    // Define our default starting index\n    const [openPanels, setOpenPanels] = useState<AccordionIndex>(() => {\n      switch (true) {\n        case isControlled:\n          return controlledIndex!;\n\n        // If we have a defaultIndex, we need to do a few checks\n        case defaultIndex != null:\n          /*\n           * If multiple is set to true, we need to make sure the `defaultIndex`\n           * is an array (and vice versa). We'll handle console warnings in\n           * our propTypes, but this will at least keep the component from\n           * blowing up.\n           */\n          if (multiple) {\n            return Array.isArray(defaultIndex) ? defaultIndex : [defaultIndex!];\n          } else {\n            return Array.isArray(defaultIndex)\n              ? defaultIndex[0] ?? 0\n              : defaultIndex!;\n          }\n\n        /*\n         * Collapsible accordions with no defaultIndex will start with all\n         * panels collapsed. Otherwise the first panel will be our default.\n         */\n        case collapsible:\n          return multiple ? [-1] : -1;\n        default:\n          return multiple ? [0] : 0;\n      }\n    });\n\n    if (__DEV__) {\n      warning(\n        !(!isControlled && wasControlled),\n        \"Accordion is changing from controlled to uncontrolled. Accordion should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Accordion for the lifetime of the component. Check the `index` prop being passed in.\"\n      );\n      warning(\n        !(isControlled && !wasControlled),\n        \"Accordion is changing from uncontrolled to controlled. Accordion should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled Accordion for the lifetime of the component. Check the `index` prop being passed in.\"\n      );\n      warning(\n        !(isControlled && collapsible),\n        \"The `collapsible` prop on Accordion has no effect when the state of the component is controlled.\"\n      );\n      warning(\n        !(isControlled && multiple),\n        \"The `multiple` prop on Accordion has no effect when the state of the component is controlled.\"\n      );\n    }\n\n    const onSelectPanel = useCallback(\n      (index: number) => {\n        onChange && onChange(index);\n\n        if (!isControlled) {\n          setOpenPanels(prevOpenPanels => {\n            /*\n             * If we're dealing with an uncontrolled component, the index arg\n             * in selectChange will always be a number rather than an array.\n             */\n            index = index as number;\n            // multiple allowed\n            if (multiple) {\n              // state will always be an array here\n              prevOpenPanels = prevOpenPanels as number[];\n              if (\n                // User is clicking on an already-open button\n                prevOpenPanels.includes(index as number)\n              ) {\n                // Other panels are open OR accordion is allowed to collapse\n                if (prevOpenPanels.length > 1 || collapsible) {\n                  // Close the panel by filtering it from the array\n                  return prevOpenPanels.filter(i => i !== index);\n                }\n              } else {\n                // Open the panel by adding it to the array.\n                return [...prevOpenPanels, index].sort();\n              }\n            } else {\n              prevOpenPanels = prevOpenPanels as number;\n              return prevOpenPanels === index && collapsible ? -1 : index;\n            }\n            return prevOpenPanels;\n          });\n        }\n      },\n      [collapsible, isControlled, multiple, onChange]\n    );\n\n    const context: IAccordionContext = useMemo(\n      () => ({\n        accordionId: id,\n        openPanels: isControlled ? controlledIndex! : openPanels,\n        onSelectPanel: readOnly ? noop : onSelectPanel,\n        readOnly,\n      }),\n      [openPanels, controlledIndex, id, isControlled, onSelectPanel, readOnly]\n    );\n\n    useEffect(() => checkStyles(\"accordion\"), []);\n\n    return (\n      <DescendantProvider\n        context={AccordionDescendantContext}\n        items={descendants}\n        set={setDescendants}\n      >\n        <AccordionContext.Provider value={context}>\n          <div {...props} ref={forwardedRef} data-reach-accordion=\"\">\n            {children}\n          </div>\n        </AccordionContext.Provider>\n      </DescendantProvider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-props\n */\nexport type AccordionProps = Omit<\n  React.HTMLProps<HTMLDivElement>,\n  \"onChange\"\n> & {\n  /**\n   * `Accordion` can accept `AccordionItem` components as children.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-children\n   */\n  children: React.ReactNode;\n  /**\n   * Whether or not all panels of an uncontrolled accordion can be toggled\n   * to a closed state. By default, an uncontrolled accordion will have an open\n   * panel at all times, meaning a panel can only be closed if the user opens\n   * another panel. This prop allows the user to collapse all open panels.\n   *\n   * It's important to note that this prop has no impact on controlled\n   * components, since the state of any given accordion panel is managed solely\n   * by the index prop.\n   */\n  collapsible?: boolean;\n  /**\n   * A default value for the open panel's index or indices in an uncontrolled\n   * accordion component when it is initially rendered.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-defaultindex\n   */\n  defaultIndex?: AccordionIndex;\n  /**\n   * The index or array of indices for open accordion panels. The `index` props\n   * should be used along with `onChange` to create controlled accordion\n   * components.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-index\n   */\n  index?: AccordionIndex;\n  /**\n   * The callback that is fired when an accordion item's open state is changed.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-onchange\n   */\n  onChange?(index?: number): void;\n  /**\n   * Whether or not an uncontrolled accordion is read-only or controllable by a\n   * user interaction.\n   *\n   * Generally speaking you probably want to avoid this, as\n   * it can be confusing especially when navigating by keyboard. However, this\n   * may be useful if you want to lock an accordion under certain conditions\n   * (perhaps user authentication is required to access the content). In these\n   * instances, you may want to include an alert when a user tries to activate\n   * a read-only accordion panel to let them know why it does not toggle as may\n   * be expected.\n   *\n   * TODO: Create example with @reach/alert.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordion-onchange\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not multiple panels in an uncontrolled accordion can be opened\n   * at the same time. By default, when a user opens a new panel, the previously\n   * opened panel will close. This prop prevents that behavior.\n   *\n   * It's important to note that this prop has no impact on controlled\n   * components, since the state of any given accordion panel is managed solely\n   * by the index prop.\n   */\n  multiple?: boolean;\n};\n\nif (__DEV__) {\n  Accordion.displayName = \"Accordion\";\n  Accordion.propTypes = {\n    children: PropTypes.node.isRequired,\n    defaultIndex: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number),\n    ]) as any,\n    index: (props, name, compName, location, propName) => {\n      let val = props[name];\n      if (props[name] != null && props.onChange == null && !props.readOnly) {\n        return new Error(\n          \"You provided an `index` prop to `Accordion` without an `onChange` handler. This will render a read-only accordion element. If the accordion should be functional, remove the `index` value to render an uncontrolled accordion or set an `onChange` handler to set an index when a change occurs. If the accordion is intended to have a fixed state, use the `readOnly` prop with a `defaultIndex` instead of an `index`.\"\n        );\n      }\n      if (props[name] != null && props.defaultIndex != null) {\n        return new Error(\n          \"You provided an `index` prop as well as a `defaultIndex` prop to `Accordion`. If you want a controlled component, use the index prop with an onChange handler. If you want an uncontrolled component, remove the index prop and use `defaultIndex` instead.\"\n        );\n      }\n      if (Array.isArray(props[name])) {\n        return props[name].some((i: any) => !isNumber(i))\n          ? new Error(\n              \"You provided an array as an index in `Accordion` but one or more of the values are not numeric. Please check to make sure all indices are valid numbers.\"\n            )\n          : null;\n      } else if (props[name] != null && !isNumber(props[name])) {\n        return new Error(\n          `Invalid prop \"${propName}\" supplied to \"${compName}\". Expected \"number\", received \"${\n            Array.isArray(val) ? \"array\" : typeof val\n          }\".`\n        );\n      }\n      return null;\n    },\n    multiple: (props, name, compName, location, propName) => {\n      if (!props[name] && Array.isArray(props.defaultIndex)) {\n        return new Error(\n          `The \"${propName}\" prop supplied to \"${compName}\" is not set or set to \"false\", but an array of indices was provided to the \"defaultIndex\" prop. \"${compName}\" can only have more than one default index if the \"${propName}\" prop is set to \"true\".`\n        );\n      } else if (props[name] != null && !isBoolean(props[name])) {\n        return new Error(\n          `Invalid prop \"${propName}\" supplied to \"${compName}\". Expected \"boolean\", received \"${\n            Array.isArray(props[name]) ? \"array\" : typeof props[name]\n          }\".`\n        );\n      }\n      return null;\n    },\n    onChange: PropTypes.func,\n    readOnly: PropTypes.bool,\n    collapsible: PropTypes.bool,\n  };\n}\n\n/**\n * AccordionItem\n *\n * A group that wraps a an accordion's button and panel components.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem\n */\nexport const AccordionItem = forwardRefWithAs<AccordionItemProps, \"div\">(\n  function AccordionItem(\n    { as: Comp = \"div\", children, disabled = false, ...props },\n    forwardedRef\n  ) {\n    const { accordionId, openPanels, readOnly } = useAccordionContext();\n    const buttonRef: ButtonRef = useRef(null);\n\n    const index = useDescendant({\n      context: AccordionDescendantContext,\n      element: buttonRef.current,\n      disabled,\n    });\n\n    // We need unique IDs for the panel and button to point to one another\n    const itemId = makeId(accordionId, index);\n    const panelId = makeId(\"panel\", itemId);\n    const buttonId = makeId(\"button\", itemId);\n\n    const open = Array.isArray(openPanels)\n      ? openPanels.includes(index)\n      : openPanels === index;\n\n    const dataAttributes = {\n      \"data-state\": open ? AccordionStates.Open : AccordionStates.Collapsed,\n      \"data-disabled\": disabled ? \"true\" : undefined,\n      \"data-read-only\": readOnly ? \"true\" : undefined,\n    };\n\n    const context: IAccordionItemContext = {\n      open,\n      disabled,\n      buttonId,\n      index,\n      itemId,\n      buttonRef,\n      panelId,\n      dataAttributes,\n    };\n\n    return (\n      <AccordionItemContext.Provider value={context}>\n        <Comp\n          {...props}\n          ref={forwardedRef}\n          data-reach-accordion-item=\"\"\n          {...dataAttributes}\n        >\n          {children}\n        </Comp>\n      </AccordionItemContext.Provider>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-props\n */\nexport type AccordionItemProps = {\n  /**\n   * An `AccordionItem` expects to receive an `AccordionButton` and\n   * `AccordionPanel` components as its children, though you can also nest other\n   * components within an `AccordionItem` if you want some persistant content\n   * that is relevant to the section but not collapsible when the\n   * `AccordionButton` is toggled.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-children\n   */\n  children: React.ReactNode;\n  /**\n   * Whether or not an accordion panel is disabled from user interaction.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionitem-disabled\n   */\n  disabled?: boolean;\n};\n\nif (__DEV__) {\n  AccordionItem.displayName = \"AccordionItem\";\n  AccordionItem.propTypes = {\n    disabled: PropTypes.bool,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * AccordionButton\n *\n * The trigger button a user clicks to interact with an accordion.\n *\n * Must be a direct child of a `AccordionItem`.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton\n */\nexport const AccordionButton = forwardRefWithAs<AccordionButtonProps, \"button\">(\n  function AccordionButton(\n    {\n      as: Comp = \"button\",\n      children,\n      onClick,\n      onKeyDown,\n      onMouseDown,\n      onPointerDown,\n      tabIndex,\n      ...props\n    },\n    forwardedRef\n  ) {\n    let { onSelectPanel } = useAccordionContext();\n\n    let {\n      open,\n      dataAttributes,\n      disabled,\n      buttonId,\n      buttonRef: ownRef,\n      index,\n      panelId,\n    } = useAccordionItemContext();\n\n    let ref = useForkedRef(forwardedRef, ownRef);\n\n    function handleClick(event: React.MouseEvent) {\n      event.preventDefault();\n      if (disabled) {\n        return;\n      }\n      ownRef.current.focus();\n      onSelectPanel(index);\n    }\n\n    let handleKeyDown = useDescendantKeyDown(AccordionDescendantContext, {\n      currentIndex: index,\n      orientation: \"vertical\",\n      key: \"element\",\n      rotate: true,\n      callback(element: HTMLElement) {\n        element && element.focus();\n      },\n      filter: button => !button.disabled,\n    });\n\n    return (\n      <Comp\n        aria-controls={panelId}\n        aria-expanded={open}\n        {...props}\n        ref={ref}\n        data-reach-accordion-button=\"\"\n        {...dataAttributes}\n        disabled={disabled || undefined}\n        id={buttonId}\n        onClick={wrapEvent(onClick, handleClick)}\n        onKeyDown={wrapEvent(onKeyDown, handleKeyDown)}\n        tabIndex={disabled ? -1 : tabIndex}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton-props\n */\nexport type AccordionButtonProps = {\n  /**\n   * Typically a text string that serves as a label for the accordion, though\n   * nested DOM nodes can be passed as well so long as they are valid children\n   * of interactive elements.\n   *\n   * @see https://github.com/w3c/html-aria/issues/54\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionbutton-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  AccordionButton.displayName = \"AccordionButton\";\n  AccordionButton.propTypes = {\n    as: PropTypes.any,\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * AccordionPanel\n *\n * The collapsible panel in which inner content for an accordion item is\n * rendered.\n *\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel\n */\nexport const AccordionPanel = forwardRefWithAs<AccordionPanelProps, \"div\">(\n  function AccordionPanel(\n    { as: Comp = \"div\", children, ...props },\n    forwardedRef\n  ) {\n    const {\n      dataAttributes,\n      panelId,\n      buttonId,\n      open,\n    } = useAccordionItemContext();\n\n    return (\n      <Comp\n        hidden={!open}\n        role=\"region\"\n        aria-labelledby={buttonId}\n        {...props}\n        ref={forwardedRef}\n        data-reach-accordion-panel=\"\"\n        {...dataAttributes}\n        id={panelId}\n        tabIndex={-1}\n      >\n        {children}\n      </Comp>\n    );\n  }\n);\n\n/**\n * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel-props\n */\nexport type AccordionPanelProps = {\n  /**\n   * Inner collapsible content for the accordion item.\n   *\n   * @see Docs https://reacttraining.com/reach-ui/accordion#accordionpanel-children\n   */\n  children: React.ReactNode;\n};\n\nif (__DEV__) {\n  AccordionPanel.displayName = \"AccordionPanel\";\n  AccordionPanel.propTypes = {\n    children: PropTypes.node,\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype DescendantProps = {\n  disabled: boolean;\n};\n\ntype ResultBox<T> = { v: T };\n\ntype ButtonRef = React.MutableRefObject<any>;\n\ntype AccordionIndex = number | number[];\n\ninterface IAccordionContext {\n  accordionId: string | undefined;\n  openPanels: AccordionIndex;\n  onSelectPanel(index: AccordionIndex): void;\n  readOnly: boolean;\n}\n\ninterface IAccordionItemContext {\n  open: boolean;\n  disabled: boolean;\n  buttonId: string;\n  index: number;\n  itemId: string;\n  buttonRef: ButtonRef;\n  panelId: string;\n  dataAttributes: {\n    \"data-state\": AccordionStates;\n    \"data-disabled\": string | undefined;\n    \"data-read-only\": string | undefined;\n  };\n}\n"],"names":["AccordionStates","AccordionDescendantContext","createDescendantContext","AccordionContext","createNamedContext","AccordionItemContext","useAccordionContext","useContext","useAccordionItemContext","Accordion","forwardRef","forwardedRef","children","defaultIndex","controlledIndex","index","onChange","readOnly","collapsible","multiple","props","isControlled","useRef","current","useDescendants","descendants","setDescendants","id","useId","useState","Array","isArray","openPanels","setOpenPanels","onSelectPanel","useCallback","prevOpenPanels","includes","length","filter","i","sort","context","useMemo","accordionId","noop","useEffect","checkStyles","React","DescendantProvider","items","set","Provider","value","ref","AccordionItem","forwardRefWithAs","as","Comp","disabled","buttonRef","useDescendant","element","itemId","makeId","panelId","buttonId","open","dataAttributes","Open","Collapsed","undefined","AccordionButton","onClick","onKeyDown","tabIndex","ownRef","useForkedRef","handleKeyDown","useDescendantKeyDown","currentIndex","orientation","key","rotate","callback","focus","button","wrapEvent","event","preventDefault","AccordionPanel","hidden","role"],"mappings":"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"}