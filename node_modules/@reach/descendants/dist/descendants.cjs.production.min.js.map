{"version":3,"file":"descendants.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React, { useCallback, useContext, useMemo, useState } from \"react\";\nimport {\n  createNamedContext,\n  noop,\n  useIsomorphicLayoutEffect,\n} from \"@reach/utils\";\n\nexport function createDescendantContext<ElementType, DescendantProps = {}>(\n  name: string,\n  initialValue = {}\n) {\n  return createNamedContext(name, {\n    descendants: [],\n    registerDescendant: noop,\n    unregisterDescendant: noop,\n    ...initialValue,\n  } as IDescendantContext<ElementType, DescendantProps>);\n}\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\nexport function useDescendant<ElementType, DescendantProps>(\n  {\n    context,\n    element,\n    ...rest\n  }: Omit<Descendant<ElementType, DescendantProps>, \"index\"> & {\n    context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  },\n  indexProp?: number\n) {\n  let [, forceUpdate] = useState();\n  let { registerDescendant, unregisterDescendant, descendants } = useContext(\n    context\n  );\n\n  // Prevent any flashing\n  useIsomorphicLayoutEffect(() => {\n    if (!element) forceUpdate({});\n    // @ts-ignore\n    registerDescendant({ element, ...rest });\n    return () => unregisterDescendant(element);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [element, ...Object.values(rest)]);\n\n  return indexProp ?? descendants.findIndex(item => item.element === element);\n}\n\nexport function useDescendants<ElementType, DescendantProps = {}>() {\n  return useState<Descendant<ElementType, DescendantProps>[]>([]);\n}\n\nexport function DescendantProvider<ElementType, DescendantProps>({\n  context: Ctx,\n  children,\n  items,\n  set,\n}: {\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>;\n  children: React.ReactNode;\n  items: Descendant<ElementType, DescendantProps>[];\n  set: React.Dispatch<\n    React.SetStateAction<Descendant<ElementType, DescendantProps>[]>\n  >;\n}) {\n  let registerDescendant = React.useCallback(\n    ({ element, ...rest }: Descendant<ElementType, DescendantProps>) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => {\n        let newItem: Descendant<ElementType, DescendantProps>;\n        let newItems: Descendant<ElementType, DescendantProps>[];\n        // If there are no items, register at index 0 and bail.\n        if (items.length === 0) {\n          newItem = {\n            element,\n            index: 0,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n          newItems = [...items, newItem];\n        } else if (items.find(item => item.element === element)) {\n          // If the element is already registered, just use the same array\n          newItems = items;\n        } else {\n          // When registering a descendant, we need to make sure we insert in\n          // into the array in the same order that it appears in the DOM. So as\n          // new descendants are added or maybe some are removed, we always know\n          // that the array is up-to-date and correct.\n          //\n          // So here we look at our registered descendants and see if the new\n          // element we are adding appears earlier than an existing descendant's\n          // DOM node via `node.compareDocumentPosition`. If it does, we insert\n          // the new element at this index. Because `registerDescendant` will be\n          // called in an effect every time the descendants state value changes,\n          // we should be sure that this index is accurate when descendent\n          // elements come or go from our component.\n          let index = items.findIndex(item => {\n            if (!item.element || !element) {\n              return false;\n            }\n            // Does this element's DOM node appear before another item in the\n            // array in our DOM tree? If so, return true to grab the index at\n            // this point in the array so we know where to insert the new\n            // element.\n            return Boolean(\n              item.element.compareDocumentPosition(element) &\n                Node.DOCUMENT_POSITION_PRECEDING\n            );\n          });\n\n          newItem = {\n            element,\n            index,\n            ...rest,\n          } as Descendant<ElementType, DescendantProps>;\n\n          // If an index is not found we will push the element to the end.\n          if (index === -1) {\n            newItems = [...items, newItem];\n          } else {\n            newItems = [\n              ...items.slice(0, index),\n              newItem,\n              ...items.slice(index),\n            ];\n          }\n        }\n        return newItems.map((item, index) => ({ ...item, index }));\n      });\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  let unregisterDescendant = useCallback(\n    (element: Descendant<ElementType>[\"element\"]) => {\n      if (!element) {\n        return;\n      }\n\n      set(items => items.filter(item => element !== item.element));\n    },\n    // set is a state setter initialized by the useDescendants hook.\n    // We can safely ignore the lint warning here because it will not change\n    // between renders.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const value: IDescendantContext<\n    ElementType,\n    DescendantProps\n  > = useMemo(() => {\n    return {\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n    };\n  }, [items, registerDescendant, unregisterDescendant]);\n\n  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;\n}\n\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\nexport function useDescendantKeyDown<ElementType, DescendantProps = {}>(\n  context: React.Context<IDescendantContext<ElementType, DescendantProps>>,\n  options: {\n    currentIndex: number | null | undefined;\n    key?: keyof Descendant<ElementType, DescendantProps>;\n    filter?: (descendant: Descendant<ElementType, DescendantProps>) => boolean;\n    orientation?: \"vertical\" | \"horizontal\" | \"both\";\n    rotate?: boolean;\n    rtl?: boolean;\n    callback(\n      nextOption: Descendant<ElementType, DescendantProps>[keyof Descendant<\n        ElementType,\n        DescendantProps\n      >]\n    ): void;\n  }\n) {\n  let { descendants } = useContext(context);\n  let {\n    currentIndex,\n    orientation = \"vertical\",\n    callback,\n    filter,\n    rotate = true,\n    rtl = false,\n  } = options;\n  let index = currentIndex ?? -1;\n\n  let key = (options.key || \"index\") as keyof Descendant<\n    ElementType,\n    DescendantProps\n  >;\n\n  return function handleKeyDown(event: React.KeyboardEvent) {\n    if (\n      ![\n        \"ArrowDown\",\n        \"ArrowUp\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"PageUp\",\n        \"PageDown\",\n        \"Home\",\n        \"End\",\n      ].includes(event.key)\n    ) {\n      return;\n    }\n\n    // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n    let selectableDescendants = descendants;\n    if (filter) {\n      selectableDescendants = [];\n      let n = -1;\n      for (let i = 0; i < descendants.length; i++) {\n        let descendant = descendants[i];\n        if (filter(descendant)) {\n          selectableDescendants.push({ ...descendant, index: n++ });\n\n          // Current index should map to the updated array vs. the original\n          // descendants array.\n          index = i === currentIndex ? n : index;\n        }\n      }\n      selectableDescendants = descendants.filter(filter);\n    }\n\n    // We need some options for any of this to work!\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      let atBottom = index === selectableDescendants.length - 1;\n      return atBottom\n        ? rotate\n          ? getFirstOption()\n          : selectableDescendants[index]\n        : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      let atTop = index === 0;\n      return atTop\n        ? rotate\n          ? getLastOption()\n          : selectableDescendants[index]\n        : selectableDescendants[\n            (index - 1 + selectableDescendants.length) %\n              selectableDescendants.length\n          ];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          callback(getNextOption()[key]);\n        }\n        break;\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          callback(getPreviousOption()[key]);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          callback((rtl ? getNextOption : getPreviousOption)()[key]);\n        }\n        break;\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          callback((rtl ? getPreviousOption : getNextOption)()[key]);\n        }\n        break;\n      case \"PageUp\":\n        event.preventDefault();\n        callback((event.ctrlKey ? getPreviousOption : getFirstOption)()[key]);\n        break;\n      case \"Home\":\n        event.preventDefault();\n        callback(getFirstOption()[key]);\n        break;\n      case \"PageDown\":\n        event.preventDefault();\n        callback((event.ctrlKey ? getNextOption : getLastOption)()[key]);\n        break;\n      case \"End\":\n        event.preventDefault();\n        callback(getLastOption()[key]);\n        break;\n    }\n  };\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\ntype SomeHTMLElement<T> = T extends HTMLElement ? T : HTMLElement;\n\nexport type Descendant<ElementType, DescendantProps = {}> = DescendantProps & {\n  element: SomeHTMLElement<ElementType> | null;\n  index: number;\n};\n\nexport interface IDescendantContext<ElementType, DescendantProps> {\n  descendants: Descendant<ElementType, DescendantProps>[];\n  registerDescendant(\n    descendant: Descendant<ElementType, DescendantProps>\n  ): void;\n  unregisterDescendant(element: SomeHTMLElement<ElementType> | null): void;\n}\n"],"names":["Ctx","context","children","items","set","registerDescendant","React","useCallback","element","rest","newItem","newItems","length","index","find","item","findIndex","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","slice","map","unregisterDescendant","filter","value","useMemo","descendants","Provider","name","initialValue","createNamedContext","noop","indexProp","forceUpdate","useState","useContext","useIsomorphicLayoutEffect","Object","values","options","currentIndex","orientation","callback","rotate","rtl","key","event","includes","selectableDescendants","n","i","descendant","push","preventDefault","getNextOption","getPreviousOption","ctrlKey","getFirstOption","getLastOption"],"mappings":"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"}